import { Component, EventEmitter, Input, Output, ViewChild } from '@angular/core';
import { MatPaginator } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { MatTable, MatTableDataSource } from '@angular/material/table';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "@angular/material/table";
import * as i3 from "@angular/material/sort";
import * as i4 from "@angular/material/paginator";
import * as i5 from "../uik-status-label/uik-status-label.component";
export class UikTableComponent {
    constructor() {
        this.columns = undefined;
        this.actionColumns = undefined;
        this.showStatusLabel = false;
        this.dataSource = new MatTableDataSource();
        this.enablePagination = false;
        this.enableSort = false;
        this.enableFiltering = false;
        this.actionButtonClicked = new EventEmitter();
        this.displayedColumns = [];
    }
    ngOnInit() {
        this.renderDisplayedColumns();
        this.renderActionColumns();
    }
    ngAfterViewInit() {
        this.renderSorting();
        this.renderPagination();
        this.renderStatusLabel();
    }
    ngOnChanges(changes) {
        if (this.table) {
            if (changes["dataSource"]) {
                this.table.dataSource = this.dataSource;
            }
            this.table.renderRows();
            this.renderSorting();
            this.renderPagination();
            this.renderStatusLabel();
        }
    }
    applyFilter(event) {
        const filterValue = event.target.value;
        this.dataSource.filter = filterValue.trim().toLowerCase();
        if (this.dataSource.paginator) {
            this.dataSource.paginator.firstPage();
        }
    }
    emitActionButtonClicked(buttonName, index) {
        // TODO: index korrigieren wie auch in checkbox Table [ITD-
        if (this.paginator && this.enablePagination === true) {
            const pageIndex = this.paginator.pageIndex;
            const pageSize = this.paginator.pageSize;
            const correctIndex = pageIndex * pageSize;
            index = index + correctIndex;
        }
        const elementId = this.dataSource.filteredData[+index].id;
        if (this.enableFiltering && !!this.dataSource.filter) {
            const indexOfFiltered = this.dataSource.data.findIndex((e) => e.id === elementId);
            if (indexOfFiltered) {
                index = indexOfFiltered.toString();
            }
        }
        const emit = {
            buttonName,
            index
        };
        this.actionButtonClicked.emit(emit);
    }
    renderDisplayedColumns() {
        if (this.columns) {
            for (const column of this.columns) {
                this.displayedColumns.push(column.name);
            }
        }
    }
    renderStatusLabel() {
        if (this.showStatusLabel) {
            if (!this.displayedColumns.includes('statusLabelColumn')) {
                this.displayedColumns.push('statusLabelColumn');
            }
            this.dataSource.data.forEach(element => element.statusLabelColumn = element.statusLabel.labelValue);
        }
    }
    renderActionColumns() {
        if (this.actionColumns) {
            for (const actionColumn of this.actionColumns) {
                this.displayedColumns.push(actionColumn.name);
            }
        }
    }
    renderSorting() {
        if (this.enableSort) {
            this.dataSource.sort = this.sort;
        }
    }
    renderPagination() {
        if (this.enablePagination) {
            this.dataSource.paginator = this.paginator;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: UikTableComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: UikTableComponent, selector: "engo-uik-table", inputs: { columns: "columns", actionColumns: "actionColumns", statusHeaderLabel: "statusHeaderLabel", showStatusLabel: "showStatusLabel", dataSource: "dataSource", enablePagination: "enablePagination", paginatorPageOptions: "paginatorPageOptions", enableSort: "enableSort", enableFiltering: "enableFiltering" }, outputs: { actionButtonClicked: "actionButtonClicked" }, viewQueries: [{ propertyName: "paginator", first: true, predicate: MatPaginator, descendants: true }, { propertyName: "sort", first: true, predicate: MatSort, descendants: true }, { propertyName: "table", first: true, predicate: MatTable, descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"enableFiltering === true\" class=\"form\">\n  <label class=\"inp\" for=\"inp\">\n    <input (keyup)=\"applyFilter($event)\" id=\"inp-search-filter\" placeholder=\" \" type=\"text\">\n    <span class=\"label\">Suchen & Filtern</span>\n    <span class=\"focus-bg\"></span>\n  </label>\n</div>\n<table #table [dataSource]=\"dataSource\" class=\"inventar-table mat-elevation-z8\" mat-table matSort>\n\n  <div *ngIf=\"enableSort\">\n    <ng-container *ngFor=\"let column of columns\" matColumnDef={{column.name}}>\n      <th *matHeaderCellDef mat-header-cell mat-sort-header> {{column.displayName}} </th>\n      <td *matCellDef=\"let element; index as i\" mat-cell>\n        <span *ngIf=\"!!column.backendPath\">{{element[column.backendPath.toString()][column.backendName]}}</span>\n        <span *ngIf=\"column.backendPath === undefined\">{{element[column.backendName]}}</span>\n      </td>\n    </ng-container>\n    <ng-container *ngIf=\"showStatusLabel\" matColumnDef=\"statusLabelColumn\">\n      <th *matHeaderCellDef mat-header-cell mat-sort-header>{{statusHeaderLabel}}</th>\n      <td *matCellDef=\"let element; index as i\" mat-cell>\n        <engo-uik-status-label [labelData]=\"element.statusLabel\"></engo-uik-status-label>\n      </td>\n    </ng-container>\n\n  </div>\n\n  <div *ngIf=\"!enableSort\">\n    <ng-container *ngFor=\"let column of columns\" matColumnDef={{column.name}}>\n      <th *matHeaderCellDef mat-header-cell> {{column.displayName}} </th>\n      <td *matCellDef=\"let element; index as i\" mat-cell>\n        <span *ngIf=\"!!column.backendPath\"\n              [style]=\"column.style\">{{element[column.backendPath.toString()][column.backendName]}}</span>\n        <span *ngIf=\"column.backendPath === undefined\" [style]=\"column.style\">{{element[column.backendName]}}</span>\n      </td>\n    </ng-container>\n    <ng-container *ngIf=\"showStatusLabel\" matColumnDef=\"statusLabelColumn\">\n      <th *matHeaderCellDef mat-header-cell mat-sort-header>{{statusHeaderLabel}}</th>\n      <td *matCellDef=\"let element; index as i\" mat-cell>\n        <engo-uik-status-label [labelData]=\"element.statusLabel\"></engo-uik-status-label>\n      </td>\n    </ng-container>\n\n  </div>\n\n  <div *ngIf=\"actionColumns\">\n    <ng-container *ngFor=\"let column of actionColumns\" matColumnDef={{column.name}}>\n      <th *matHeaderCellDef mat-header-cell> {{column.displayName}} </th>\n      <td *matCellDef=\"let element; index as i\" mat-cell>\n        <a (click)=\"emitActionButtonClicked(column.name, i)\" class=\"btn-icon-button action-button\">\n          <i (click)=\"emitActionButtonClicked(column.name, i)\" [id]=\"'callAction'\" [ngClass]=\"column.faIconName\"></i>\n        </a>\n      </td>\n    </ng-container>\n  </div>\n\n  <tr *matHeaderRowDef=\"displayedColumns; sticky: true\" mat-header-row></tr>\n  <tr *matRowDef=\"let element; columns: displayedColumns;\" mat-row></tr>\n</table>\n<mat-paginator *ngIf=\"enablePagination\"\n               [pageSizeOptions]=\"paginatorPageOptions && paginatorPageOptions.length > 0 ? paginatorPageOptions : [10, 25, 50, 100, 200]\"\n               showFirstLastButtons></mat-paginator>\n", styles: ["table.mat-mdc-table{display:table;width:100%}table{position:sticky}.action-button{cursor:pointer}.form{float:left}\n"], dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2.MatTable, selector: "mat-table, table[mat-table]", exportAs: ["matTable"] }, { kind: "directive", type: i2.MatHeaderCellDef, selector: "[matHeaderCellDef]" }, { kind: "directive", type: i2.MatHeaderRowDef, selector: "[matHeaderRowDef]", inputs: ["matHeaderRowDef", "matHeaderRowDefSticky"] }, { kind: "directive", type: i2.MatColumnDef, selector: "[matColumnDef]", inputs: ["sticky", "matColumnDef"] }, { kind: "directive", type: i2.MatCellDef, selector: "[matCellDef]" }, { kind: "directive", type: i2.MatRowDef, selector: "[matRowDef]", inputs: ["matRowDefColumns", "matRowDefWhen"] }, { kind: "directive", type: i2.MatHeaderCell, selector: "mat-header-cell, th[mat-header-cell]" }, { kind: "directive", type: i2.MatCell, selector: "mat-cell, td[mat-cell]" }, { kind: "component", type: i2.MatHeaderRow, selector: "mat-header-row, tr[mat-header-row]", exportAs: ["matHeaderRow"] }, { kind: "component", type: i2.MatRow, selector: "mat-row, tr[mat-row]", exportAs: ["matRow"] }, { kind: "directive", type: i3.MatSort, selector: "[matSort]", inputs: ["matSortDisabled", "matSortActive", "matSortStart", "matSortDirection", "matSortDisableClear"], outputs: ["matSortChange"], exportAs: ["matSort"] }, { kind: "component", type: i3.MatSortHeader, selector: "[mat-sort-header]", inputs: ["disabled", "mat-sort-header", "arrowPosition", "start", "sortActionDescription", "disableClear"], exportAs: ["matSortHeader"] }, { kind: "component", type: i4.MatPaginator, selector: "mat-paginator", inputs: ["disabled"], exportAs: ["matPaginator"] }, { kind: "component", type: i5.UikStatusLabelComponent, selector: "engo-uik-status-label", inputs: ["labelData"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: UikTableComponent, decorators: [{
            type: Component,
            args: [{ selector: 'engo-uik-table', template: "<div *ngIf=\"enableFiltering === true\" class=\"form\">\n  <label class=\"inp\" for=\"inp\">\n    <input (keyup)=\"applyFilter($event)\" id=\"inp-search-filter\" placeholder=\" \" type=\"text\">\n    <span class=\"label\">Suchen & Filtern</span>\n    <span class=\"focus-bg\"></span>\n  </label>\n</div>\n<table #table [dataSource]=\"dataSource\" class=\"inventar-table mat-elevation-z8\" mat-table matSort>\n\n  <div *ngIf=\"enableSort\">\n    <ng-container *ngFor=\"let column of columns\" matColumnDef={{column.name}}>\n      <th *matHeaderCellDef mat-header-cell mat-sort-header> {{column.displayName}} </th>\n      <td *matCellDef=\"let element; index as i\" mat-cell>\n        <span *ngIf=\"!!column.backendPath\">{{element[column.backendPath.toString()][column.backendName]}}</span>\n        <span *ngIf=\"column.backendPath === undefined\">{{element[column.backendName]}}</span>\n      </td>\n    </ng-container>\n    <ng-container *ngIf=\"showStatusLabel\" matColumnDef=\"statusLabelColumn\">\n      <th *matHeaderCellDef mat-header-cell mat-sort-header>{{statusHeaderLabel}}</th>\n      <td *matCellDef=\"let element; index as i\" mat-cell>\n        <engo-uik-status-label [labelData]=\"element.statusLabel\"></engo-uik-status-label>\n      </td>\n    </ng-container>\n\n  </div>\n\n  <div *ngIf=\"!enableSort\">\n    <ng-container *ngFor=\"let column of columns\" matColumnDef={{column.name}}>\n      <th *matHeaderCellDef mat-header-cell> {{column.displayName}} </th>\n      <td *matCellDef=\"let element; index as i\" mat-cell>\n        <span *ngIf=\"!!column.backendPath\"\n              [style]=\"column.style\">{{element[column.backendPath.toString()][column.backendName]}}</span>\n        <span *ngIf=\"column.backendPath === undefined\" [style]=\"column.style\">{{element[column.backendName]}}</span>\n      </td>\n    </ng-container>\n    <ng-container *ngIf=\"showStatusLabel\" matColumnDef=\"statusLabelColumn\">\n      <th *matHeaderCellDef mat-header-cell mat-sort-header>{{statusHeaderLabel}}</th>\n      <td *matCellDef=\"let element; index as i\" mat-cell>\n        <engo-uik-status-label [labelData]=\"element.statusLabel\"></engo-uik-status-label>\n      </td>\n    </ng-container>\n\n  </div>\n\n  <div *ngIf=\"actionColumns\">\n    <ng-container *ngFor=\"let column of actionColumns\" matColumnDef={{column.name}}>\n      <th *matHeaderCellDef mat-header-cell> {{column.displayName}} </th>\n      <td *matCellDef=\"let element; index as i\" mat-cell>\n        <a (click)=\"emitActionButtonClicked(column.name, i)\" class=\"btn-icon-button action-button\">\n          <i (click)=\"emitActionButtonClicked(column.name, i)\" [id]=\"'callAction'\" [ngClass]=\"column.faIconName\"></i>\n        </a>\n      </td>\n    </ng-container>\n  </div>\n\n  <tr *matHeaderRowDef=\"displayedColumns; sticky: true\" mat-header-row></tr>\n  <tr *matRowDef=\"let element; columns: displayedColumns;\" mat-row></tr>\n</table>\n<mat-paginator *ngIf=\"enablePagination\"\n               [pageSizeOptions]=\"paginatorPageOptions && paginatorPageOptions.length > 0 ? paginatorPageOptions : [10, 25, 50, 100, 200]\"\n               showFirstLastButtons></mat-paginator>\n", styles: ["table.mat-mdc-table{display:table;width:100%}table{position:sticky}.action-button{cursor:pointer}.form{float:left}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { columns: [{
                type: Input
            }], actionColumns: [{
                type: Input
            }], statusHeaderLabel: [{
                type: Input
            }], showStatusLabel: [{
                type: Input
            }], dataSource: [{
                type: Input
            }], enablePagination: [{
                type: Input
            }], paginatorPageOptions: [{
                type: Input
            }], enableSort: [{
                type: Input
            }], enableFiltering: [{
                type: Input
            }], actionButtonClicked: [{
                type: Output
            }], paginator: [{
                type: ViewChild,
                args: [MatPaginator]
            }], sort: [{
                type: ViewChild,
                args: [MatSort]
            }], table: [{
                type: ViewChild,
                args: [MatTable]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidWlrLXRhYmxlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2VuZ28tdWkta2l0LWxpYi9zcmMvbGliL3Vpay10YWJsZS91aWstdGFibGUuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvZW5nby11aS1raXQtbGliL3NyYy9saWIvdWlrLXRhYmxlL3Vpay10YWJsZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ1UsU0FBUyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQXFCLE1BQU0sRUFBaUIsU0FBUyxFQUNuRyxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDM0QsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ2pELE9BQU8sRUFBRSxRQUFRLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQzs7Ozs7OztBQVF2RSxNQUFNLE9BQU8saUJBQWlCO0lBdUI1QjtRQXRCUyxZQUFPLEdBQTJCLFNBQVMsQ0FBQztRQUM1QyxrQkFBYSxHQUFtQyxTQUFTLENBQUM7UUFFMUQsb0JBQWUsR0FBRyxLQUFLLENBQUM7UUFDeEIsZUFBVSxHQUE0QixJQUFJLGtCQUFrQixFQUFFLENBQUM7UUFDL0QscUJBQWdCLEdBQUcsS0FBSyxDQUFDO1FBRXpCLGVBQVUsR0FBRyxLQUFLLENBQUM7UUFDbkIsb0JBQWUsR0FBRyxLQUFLLENBQUM7UUFFdkIsd0JBQW1CLEdBQXVDLElBQUksWUFBWSxFQUF3QixDQUFDO1FBVTdHLHFCQUFnQixHQUFhLEVBQUUsQ0FBQztJQUdoQyxDQUFDO0lBRUQsUUFBUTtRQUNOLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO1FBQzlCLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO0lBQzdCLENBQUM7SUFFRCxlQUFl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R0gsSUFBSTtzQkFBdkIsU0FBUzt1QkFBQyxPQUFPO2dCQUdsQixLQUFLO3NCQURKLFNBQVM7dUJBQUMsUUFBUSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25DaGFuZ2VzLCBPbkluaXQsIE91dHB1dCwgU2ltcGxlQ2hhbmdlcywgVmlld0NoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWF0UGFnaW5hdG9yIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvcGFnaW5hdG9yJztcbmltcG9ydCB7IE1hdFNvcnQgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9zb3J0JztcbmltcG9ydCB7IE1hdFRhYmxlLCBNYXRUYWJsZURhdGFTb3VyY2UgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC90YWJsZSc7XG5pbXBvcnQgeyBJQWN0aW9uQ29sdW1uQ2xpY2tlZCwgSUFjdGlvbkNvbHVtbnMsIElDb2x1bW5zIH0gZnJvbSAnLi9pbnRlcmZhY2VzL3Vpay10YWJsZS5pbnRlcmZhY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdlbmdvLXVpay10YWJsZScsXG4gIHRlbXBsYXRlVXJsOiAnLi91aWstdGFibGUuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi91aWstdGFibGUuY29tcG9uZW50LmNzcyddXG59KVxuZXhwb3J0IGNsYXNzIFVpa1RhYmxlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIEFmdGVyVmlld0luaXQge1xuICBASW5wdXQoKSBjb2x1bW5zOiBJQ29sdW1uc1tdIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBASW5wdXQoKSBhY3Rpb25Db2x1bW5zPzogSUFjdGlvbkNvbHVtbnMgW10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIEBJbnB1dCgpIHN0YXR1c0hlYWRlckxhYmVsPzogc3RyaW5nO1xuICBASW5wdXQoKSBzaG93U3RhdHVzTGFiZWwgPSBmYWxzZTtcbiAgQElucHV0KCkgZGF0YVNvdXJjZTogTWF0VGFibGVEYXRhU291cmNlPGFueT4gPSBuZXcgTWF0VGFibGVEYXRhU291cmNlKCk7XG4gIEBJbnB1dCgpIGVuYWJsZVBhZ2luYXRpb24gPSBmYWxzZTtcbiAgQElucHV0KCkgcGFnaW5hdG9yUGFnZU9wdGlvbnM/OiBBcnJheTxudW1iZXI+O1xuICBASW5wdXQoKSBlbmFibGVTb3J0ID0gZmFsc2U7XG4gIEBJbnB1dCgpIGVuYWJsZUZpbHRlcmluZyA9IGZhbHNlO1xuXG4gIEBPdXRwdXQoKSBhY3Rpb25CdXR0b25DbGlja2VkOiBFdmVudEVtaXR0ZXI8SUFjdGlvbkNvbHVtbkNsaWNrZWQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJQWN0aW9uQ29sdW1uQ2xpY2tlZD4oKTtcblxuICBAVmlld0NoaWxkKE1hdFBhZ2luYXRvcilcbiAgcGFnaW5hdG9yITogTWF0UGFnaW5hdG9yIHwgbnVsbDtcblxuICBAVmlld0NoaWxkKE1hdFNvcnQpIHNvcnQhOiBNYXRTb3J0O1xuXG4gIEBWaWV3Q2hpbGQoTWF0VGFibGUpXG4gIHRhYmxlITogTWF0VGFibGU8YW55PjtcblxuICBkaXNwbGF5ZWRDb2x1bW5zOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5yZW5kZXJEaXNwbGF5ZWRDb2x1bW5zKCk7XG4gICAgdGhpcy5yZW5kZXJBY3Rpb25Db2x1bW5zKCk7XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgdGhpcy5yZW5kZXJTb3J0aW5nKCk7XG4gICAgdGhpcy5yZW5kZXJQYWdpbmF0aW9uKCk7XG4gICAgdGhpcy5yZW5kZXJTdGF0dXNMYWJlbCgpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGlmICh0aGlzLnRhYmxlKSB7XG4gICAgICBpZiAoY2hhbmdlc1tcImRhdGFTb3VyY2VcIl0pIHtcbiAgICAgICAgdGhpcy50YWJsZS5kYXRhU291cmNlID0gdGhpcy5kYXRhU291cmNlO1xuICAgICAgfVxuICAgICAgdGhpcy50YWJsZS5yZW5kZXJSb3dzKCk7XG4gICAgICB0aGlzLnJlbmRlclNvcnRpbmcoKTtcbiAgICAgIHRoaXMucmVuZGVyUGFnaW5hdGlvbigpO1xuICAgICAgdGhpcy5yZW5kZXJTdGF0dXNMYWJlbCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhcHBseUZpbHRlcihldmVudDogRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCBmaWx0ZXJWYWx1ZSA9IChldmVudC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWU7XG4gICAgdGhpcy5kYXRhU291cmNlLmZpbHRlciA9IGZpbHRlclZhbHVlLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKHRoaXMuZGF0YVNvdXJjZS5wYWdpbmF0b3IpIHtcbiAgICAgIHRoaXMuZGF0YVNvdXJjZS5wYWdpbmF0b3IuZmlyc3RQYWdlKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGVtaXRBY3Rpb25CdXR0b25DbGlja2VkKGJ1dHRvbk5hbWU6IHN0cmluZywgaW5kZXg6IHN0cmluZyk6IHZvaWQge1xuICAgIC8vIFRPRE86IGluZGV4IGtvcnJpZ2llcmVuIHdpZSBhdWNoIGluIGNoZWNrYm94IFRhYmxlIFtJVEQtXG4gICAgaWYgKHRoaXMucGFnaW5hdG9yICYmIHRoaXMuZW5hYmxlUGFnaW5hdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3QgcGFnZUluZGV4ID0gdGhpcy5wYWdpbmF0b3IucGFnZUluZGV4O1xuICAgICAgY29uc3QgcGFnZVNpemUgPSB0aGlzLnBhZ2luYXRvci5wYWdlU2l6ZTtcbiAgICAgIGNvbnN0IGNvcnJlY3RJbmRleCA9IHBhZ2VJbmRleCAqIHBhZ2VTaXplO1xuICAgICAgaW5kZXggPSBpbmRleCArIGNvcnJlY3RJbmRleDtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudElkID0gdGhpcy5kYXRhU291cmNlLmZpbHRlcmVkRGF0YVsraW5kZXhdLmlkO1xuICAgIGlmICh0aGlzLmVuYWJsZUZpbHRlcmluZyAmJiAhIXRoaXMuZGF0YVNvdXJjZS5maWx0ZXIpIHtcbiAgICAgIGNvbnN0IGluZGV4T2ZGaWx0ZXJlZCA9IHRoaXMuZGF0YVNvdXJjZS5kYXRhLmZpbmRJbmRleCgoZSkgPT4gZS5pZCA9PT0gZWxlbWVudElkKTtcbiAgICAgIGlmIChpbmRleE9mRmlsdGVyZWQpIHtcbiAgICAgICAgaW5kZXggPSBpbmRleE9mRmlsdGVyZWQudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZW1pdDogSUFjdGlvbkNvbHVtbkNsaWNrZWQgPSB7XG4gICAgICBidXR0b25OYW1lLFxuICAgICAgaW5kZXhcbiAgICB9O1xuICAgIHRoaXMuYWN0aW9uQnV0dG9uQ2xpY2tlZC5lbWl0KGVtaXQpO1xuICB9XG5cbiAgcHJpdmF0ZSByZW5kZXJEaXNwbGF5ZWRDb2x1bW5zKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNvbHVtbnMpIHtcbiAgICAgIGZvciAoY29uc3QgY29sdW1uIG9mIHRoaXMuY29sdW1ucykge1xuICAgICAgICB0aGlzLmRpc3BsYXllZENvbHVtbnMucHVzaChjb2x1bW4ubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZW5kZXJTdGF0dXNMYWJlbCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zaG93U3RhdHVzTGFiZWwpIHtcbiAgICAgIGlmICghdGhpcy5kaXNwbGF5ZWRDb2x1bW5zLmluY2x1ZGVzKCdzdGF0dXNMYWJlbENvbHVtbicpKSB7XG4gICAgICAgIHRoaXMuZGlzcGxheWVkQ29sdW1ucy5wdXNoKCdzdGF0dXNMYWJlbENvbHVtbicpO1xuICAgICAgfVxuICAgICAgdGhpcy5kYXRhU291cmNlLmRhdGEuZm9yRWFjaChlbGVtZW50ID0+IGVsZW1lbnQuc3RhdHVzTGFiZWxDb2x1bW4gPSBlbGVtZW50LnN0YXR1c0xhYmVsLmxhYmVsVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVuZGVyQWN0aW9uQ29sdW1ucygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5hY3Rpb25Db2x1bW5zKSB7XG4gICAgICBmb3IgKGNvbnN0IGFjdGlvbkNvbHVtbiBvZiB0aGlzLmFjdGlvbkNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRDb2x1bW5zLnB1c2goYWN0aW9uQ29sdW1uLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVuZGVyU29ydGluZygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5lbmFibGVTb3J0KSB7XG4gICAgICB0aGlzLmRhdGFTb3VyY2Uuc29ydCA9IHRoaXMuc29ydDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlbmRlclBhZ2luYXRpb24oKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZW5hYmxlUGFnaW5hdGlvbikge1xuICAgICAgdGhpcy5kYXRhU291cmNlLnBhZ2luYXRvciA9IHRoaXMucGFnaW5hdG9yO1xuICAgIH1cbiAgfVxuXG59XG4iLCI8ZGl2ICpuZ0lmPVwiZW5hYmxlRmlsdGVyaW5nID09PSB0cnVlXCIgY2xhc3M9XCJmb3JtXCI+XG4gIDxsYWJlbCBjbGFzcz1cImlucFwiIGZvcj1cImlucFwiPlxuICAgIDxpbnB1dCAoa2V5dXApPVwiYXBwbHlGaWx0ZXIoJGV2ZW50KVwiIGlkPVwiaW5wLXNlYXJjaC1maWx0ZXJcIiBwbGFjZWhvbGRlcj1cIiBcIiB0eXBlPVwidGV4dFwiPlxuICAgIDxzcGFuIGNsYXNzPVwibGFiZWxcIj5TdWNoZW4gJiBGaWx0ZXJuPC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwiZm9jdXMtYmdcIj48L3NwYW4+XG4gIDwvbGFiZWw+XG48L2Rpdj5cbjx0YWJsZSAjdGFibGUgW2RhdGFTb3VyY2VdPVwiZGF0YVNvdXJjZVwiIGNsYXNzPVwiaW52ZW50YXItdGFibGUgbWF0LWVsZXZhdGlvbi16OFwiIG1hdC10YWJsZSBtYXRTb3J0PlxuXG4gIDxkaXYgKm5nSWY9XCJlbmFibGVTb3J0XCI+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGNvbHVtbnNcIiBtYXRDb2x1bW5EZWY9e3tjb2x1bW4ubmFtZX19PlxuICAgICAgPHRoICptYXRIZWFkZXJDZWxsRGVmIG1hdC1oZWFkZXItY2VsbCBtYXQtc29ydC1oZWFkZXI+IHt7Y29sdW1uLmRpc3BsYXlOYW1lfX0gPC90aD5cbiAgICAgIDx0ZCAqbWF0Q2VsbERlZj1cImxldCBlbGVtZW50OyBpbmRleCBhcyBpXCIgbWF0LWNlbGw+XG4gICAgICAgIDxzcGFuICpuZ0lmPVwiISFjb2x1bW4uYmFja2VuZFBhdGhcIj57e2VsZW1lbnRbY29sdW1uLmJhY2tlbmRQYXRoLnRvU3RyaW5nKCldW2NvbHVtbi5iYWNrZW5kTmFtZV19fTwvc3Bhbj5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJjb2x1bW4uYmFja2VuZFBhdGggPT09IHVuZGVmaW5lZFwiPnt7ZWxlbWVudFtjb2x1bW4uYmFja2VuZE5hbWVdfX08L3NwYW4+XG4gICAgICA8L3RkPlxuICAgIDwvbmctY29udGFpbmVyPlxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJzaG93U3RhdHVzTGFiZWxcIiBtYXRDb2x1bW5EZWY9XCJzdGF0dXNMYWJlbENvbHVtblwiPlxuICAgICAgPHRoICptYXRIZWFkZXJDZWxsRGVmIG1hdC1oZWFkZXItY2VsbCBtYXQtc29ydC1oZWFkZXI+e3tzdGF0dXNIZWFkZXJMYWJlbH19PC90aD5cbiAgICAgIDx0ZCAqbWF0Q2VsbERlZj1cImxldCBlbGVtZW50OyBpbmRleCBhcyBpXCIgbWF0LWNlbGw+XG4gICAgICAgIDxlbmdvLXVpay1zdGF0dXMtbGFiZWwgW2xhYmVsRGF0YV09XCJlbGVtZW50LnN0YXR1c0xhYmVsXCI+PC9lbmdvLXVpay1zdGF0dXMtbGFiZWw+XG4gICAgICA8L3RkPlxuICAgIDwvbmctY29udGFpbmVyPlxuXG4gIDwvZGl2PlxuXG4gIDxkaXYgKm5nSWY9XCIhZW5hYmxlU29ydFwiPlxuICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBjb2x1bW5zXCIgbWF0Q29sdW1uRGVmPXt7Y29sdW1uLm5hbWV9fT5cbiAgICAgIDx0aCAqbWF0SGVhZGVyQ2VsbERlZiBtYXQtaGVhZGVyLWNlbGw+IHt7Y29sdW1uLmRpc3BsYXlOYW1lfX0gPC90aD5cbiAgICAgIDx0ZCAqbWF0Q2VsbERlZj1cImxldCBlbGVtZW50OyBpbmRleCBhcyBpXCIgbWF0LWNlbGw+XG4gICAgICAgIDxzcGFuICpuZ0lmPVwiISFjb2x1bW4uYmFja2VuZFBhdGhcIlxuICAgICAgICAgICAgICBbc3R5bGVdPVwiY29sdW1uLnN0eWxlXCI+e3tlbGVtZW50W2NvbHVtbi5iYWNrZW5kUGF0aC50b1N0cmluZygpXVtjb2x1bW4uYmFja2VuZE5hbWVdfX08L3NwYW4+XG4gICAgICAgIDxzcGFuICpuZ0lmPVwiY29sdW1uLmJhY2tlbmRQYXRoID09PSB1bmRlZmluZWRcIiBbc3R5bGVdPVwiY29sdW1uLnN0eWxlXCI+e3tlbGVtZW50W2NvbHVtbi5iYWNrZW5kTmFtZV19fTwvc3Bhbj5cbiAgICAgIDwvdGQ+XG4gICAgPC9uZy1jb250YWluZXI+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInNob3dTdGF0dXNMYWJlbFwiIG1hdENvbHVtbkRlZj1cInN0YXR1c0xhYmVsQ29sdW1uXCI+XG4gICAgICA8dGggKm1hdEhlYWRlckNlbGxEZWYgbWF0LWhlYWRlci1jZWxsIG1hdC1zb3J0LWhlYWRlcj57e3N0YXR1c0hlYWRlckxhYmVsfX08L3RoPlxuICAgICAgPHRkICptYXRDZWxsRGVmPVwibGV0IGVsZW1lbnQ7IGluZGV4IGFzIGlcIiBtYXQtY2VsbD5cbiAgICAgICAgPGVuZ28tdWlrLXN0YXR1cy1sYWJlbCBbbGFiZWxEYXRhXT1cImVsZW1lbnQuc3RhdHVzTGFiZWxcIj48L2VuZ28tdWlrLXN0YXR1cy1sYWJlbD5cbiAgICAgIDwvdGQ+XG4gICAgPC9uZy1jb250YWluZXI+XG5cbiAgPC9kaXY+XG5cbiAgPGRpdiAqbmdJZj1cImFjdGlvbkNvbHVtbnNcIj5cbiAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBjb2x1bW4gb2YgYWN0aW9uQ29sdW1uc1wiIG1hdENvbHVtbkRlZj17e2NvbHVtbi5uYW1lfX0+XG4gICAgICA8dGggKm1hdEhlYWRlckNlbGxEZWYgbWF0LWhlYWRlci1jZWxsPiB7e2NvbHVtbi5kaXNwbGF5TmFtZX19IDwvdGg+XG4gICAgICA8dGQgKm1hdENlbGxEZWY9XCJsZXQgZWxlbWVudDsgaW5kZXggYXMgaVwiIG1hdC1jZWxsPlxuICAgICAgICA8YSAoY2xpY2spPVwiZW1pdEFjdGlvbkJ1dHRvbkNsaWNrZWQoY29sdW1uLm5hbWUsIGkpXCIgY2xhc3M9XCJidG4taWNvbi1idXR0b24gYWN0aW9uLWJ1dHRvblwiPlxuICAgICAgICAgIDxpIChjbGljayk9XCJlbWl0QWN0aW9uQnV0dG9uQ2xpY2tlZChjb2x1bW4ubmFtZSwgaSlcIiBbaWRdPVwiJ2NhbGxBY3Rpb24nXCIgW25nQ2xhc3NdPVwiY29sdW1uLmZhSWNvbk5hbWVcIj48L2k+XG4gICAgICAgIDwvYT5cbiAgICAgIDwvdGQ+XG4gICAgPC9uZy1jb250YWluZXI+XG4gIDwvZGl2PlxuXG4gIDx0ciAqbWF0SGVhZGVyUm93RGVmPVwiZGlzcGxheWVkQ29sdW1uczsgc3RpY2t5OiB0cnVlXCIgbWF0LWhlYWRlci1yb3c+PC90cj5cbiAgPHRyICptYXRSb3dEZWY9XCJsZXQgZWxlbWVudDsgY29sdW1uczogZGlzcGxheWVkQ29sdW1ucztcIiBtYXQtcm93PjwvdHI+XG48L3RhYmxlPlxuPG1hdC1wYWdpbmF0b3IgKm5nSWY9XCJlbmFibGVQYWdpbmF0aW9uXCJcbiAgICAgICAgICAgICAgIFtwYWdlU2l6ZU9wdGlvbnNdPVwicGFnaW5hdG9yUGFnZU9wdGlvbnMgJiYgcGFnaW5hdG9yUGFnZU9wdGlvbnMubGVuZ3RoID4gMCA/IHBhZ2luYXRvclBhZ2VPcHRpb25zIDogWzEwLCAyNSwgNTAsIDEwMCwgMjAwXVwiXG4gICAgICAgICAgICAgICBzaG93Rmlyc3RMYXN0QnV0dG9ucz48L21hdC1wYWdpbmF0b3I+XG4iXX0=