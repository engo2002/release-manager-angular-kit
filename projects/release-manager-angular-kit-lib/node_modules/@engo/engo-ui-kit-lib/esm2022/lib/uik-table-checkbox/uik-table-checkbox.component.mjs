import { Component, EventEmitter, Input, Output, ViewChild } from '@angular/core';
import { MatPaginator } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { MatTable, MatTableDataSource } from '@angular/material/table';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "@angular/material/table";
import * as i3 from "@angular/material/sort";
import * as i4 from "@angular/material/paginator";
import * as i5 from "@angular/material/checkbox";
import * as i6 from "../uik-status-label/uik-status-label.component";
export class UikTableCheckboxComponent {
    constructor() {
        this.columns = undefined;
        this.showStatusLabel = true;
        this.dataSource = new MatTableDataSource();
        this.enablePagination = false;
        this.enableSort = false;
        this.enableFiltering = false;
        this.enableMultipleChecked = true;
        this.checkboxClickedMultipleEmitter = new EventEmitter();
        this.checkboxClickedSingleEmitter = new EventEmitter();
        this.displayedColumns = [];
        this.checkboxClickedMultipleArray = [];
        this.checkboxClickedSingleArray = undefined;
        this.pageIndex = 0;
        this.pageSize = 0;
        this.correctIndex = 0;
    }
    ngOnInit() {
        this.renderDisplayedColumns();
    }
    ngAfterViewInit() {
        this.renderSorting();
        this.renderPagination();
        this.renderStatusLabel();
    }
    ngOnChanges(changes) {
        if (this.table) {
            if (changes["dataSource"]) {
                this.table.dataSource = this.dataSource;
            }
            this.table.renderRows();
            this.renderSorting();
            this.renderPagination();
            this.renderStatusLabel();
        }
    }
    applyFilter(event) {
        const filterValue = event.target.value;
        this.dataSource.filter = filterValue.trim().toLowerCase();
        if (this.dataSource.paginator) {
            this.dataSource.paginator.firstPage();
        }
        if (this.enableMultipleChecked === false) {
            this.checkboxClickedSingleArray = { elementId: -1 };
            this.emitCheckboxClickedSingle();
        }
        if (this.enableMultipleChecked === true) {
            this.checkboxClickedMultipleArray = [];
            this.emitCheckboxClickedMultiple();
        }
    }
    getSelectedRow(event, index) {
        if (this.paginator && this.enablePagination === true) {
            this.pageIndex = this.paginator.pageIndex;
            this.pageSize = this.paginator.pageSize;
            this.correctIndex = this.pageIndex * this.pageSize;
            index = index + this.correctIndex;
        }
        const elementId = this.dataSource.filteredData[index].id;
        if (event.checked === true) {
            if (this.enableMultipleChecked === false) {
                this.checkboxClickedSingleArray = { elementId };
                this.emitCheckboxClickedSingle();
            }
            if (this.enableMultipleChecked === true) {
                this.checkboxClickedMultipleArray.push({ elementId });
                this.emitCheckboxClickedMultiple();
            }
        }
        if (event.checked === false) {
            if (this.enableMultipleChecked === false) {
                this.checkboxClickedSingleArray = { elementId: -1 };
                this.emitCheckboxClickedSingle();
            }
            if (this.enableMultipleChecked === true) {
                const arrayIndex = this.checkboxClickedMultipleArray.findIndex(e => e.elementId === elementId);
                this.checkboxClickedMultipleArray.splice(arrayIndex, 1);
                this.emitCheckboxClickedMultiple();
            }
        }
    }
    onChangePagination() {
        if (this.enableMultipleChecked === false) {
            this.checkboxClickedSingleArray = { elementId: -1 };
            this.emitCheckboxClickedSingle();
        }
        if (this.enableMultipleChecked === true) {
            this.checkboxClickedMultipleArray = [];
            this.emitCheckboxClickedMultiple();
        }
    }
    checkSelectedMultipleInArray(id) {
        return this.checkboxClickedMultipleArray.findIndex(element => element.elementId === id);
    }
    emitCheckboxClickedMultiple() {
        this.checkboxClickedMultipleEmitter.emit(this.checkboxClickedMultipleArray);
    }
    emitCheckboxClickedSingle() {
        this.checkboxClickedSingleEmitter.emit(this.checkboxClickedSingleArray);
    }
    renderDisplayedColumns() {
        if (this.columns) {
            this.displayedColumns.push('checkboxColumn');
            for (const column of this.columns) {
                this.displayedColumns.push(column.name);
            }
        }
    }
    renderStatusLabel() {
        if (this.showStatusLabel) {
            if (!this.displayedColumns.includes('statusLabelColumn')) {
                this.displayedColumns.push('statusLabelColumn');
            }
            this.dataSource.data.forEach(element => element.statusLabelColumn = element.statusLabel.labelValue);
        }
    }
    renderSorting() {
        if (this.enableSort) {
            this.dataSource.sort = this.sort;
        }
    }
    renderPagination() {
        if (this.enablePagination) {
            this.dataSource.paginator = this.paginator;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: UikTableCheckboxComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: UikTableCheckboxComponent, selector: "engo-uik-table-checkbox", inputs: { columns: "columns", statusHeaderLabel: "statusHeaderLabel", showStatusLabel: "showStatusLabel", dataSource: "dataSource", enablePagination: "enablePagination", paginatorPageOptions: "paginatorPageOptions", enableSort: "enableSort", enableFiltering: "enableFiltering", enableMultipleChecked: "enableMultipleChecked" }, outputs: { checkboxClickedMultipleEmitter: "checkboxClickedMultipleEmitter", checkboxClickedSingleEmitter: "checkboxClickedSingleEmitter" }, viewQueries: [{ propertyName: "paginator", first: true, predicate: MatPaginator, descendants: true }, { propertyName: "sort", first: true, predicate: MatSort, descendants: true }, { propertyName: "table", first: true, predicate: MatTable, descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"enableFiltering === true\" class=\"form\">\n  <label class=\"inp\" for=\"inp\">\n    <input (keyup)=\"applyFilter($event)\" id=\"inp-search-filter\" placeholder=\" \" type=\"text\">\n    <span class=\"label\">Suchen & Filtern</span>\n    <span class=\"focus-bg\"></span>\n  </label>\n</div>\n<table #table [dataSource]=\"dataSource\" class=\"inventar-table mat-elevation-z8\" mat-table matSort>\n  <ng-container matColumnDef=\"checkboxColumn\">\n    <th *matHeaderCellDef mat-header-cell></th>\n    <td *matCellDef=\"let element; index as i;\" mat-cell>\n      <mat-checkbox (change)=\"getSelectedRow($event, i)\" *ngIf=\"enableMultipleChecked === true\"\n                    [checked]=\"checkSelectedMultipleInArray(element.id) !== -1\">\n      </mat-checkbox>\n      <mat-checkbox (change)=\"getSelectedRow($event, i)\"\n                    *ngIf=\"enableMultipleChecked === false\"\n                    [checked]=\"checkboxClickedSingleArray?.elementId === element.id\">\n      </mat-checkbox>\n    </td>\n  </ng-container>\n  <div *ngIf=\"enableSort\">\n    <ng-container *ngFor=\"let column of columns\" matColumnDef={{column.name}}>\n      <th *matHeaderCellDef mat-header-cell mat-sort-header> {{column.displayName}} </th>\n      <td *matCellDef=\"let element; index as i\" mat-cell>\n        <span *ngIf=\"!!column.backendPath\"\n              [style]=\"column.style\">{{element[column.backendPath.toString()][column.backendName]}}</span>\n        <span *ngIf=\"column.backendPath === undefined\" [style]=\"column.style\">{{element[column.backendName]}}</span>\n      </td>\n    </ng-container>\n    <ng-container *ngIf=\"showStatusLabel\" matColumnDef=\"statusLabelColumn\">\n      <th *matHeaderCellDef mat-header-cell mat-sort-header>{{statusHeaderLabel}}</th>\n      <td *matCellDef=\"let element; index as i\" mat-cell>\n        <engo-uik-status-label [labelData]=\"element.statusLabel\"></engo-uik-status-label>\n      </td>\n    </ng-container>\n\n  </div>\n\n  <div *ngIf=\"!enableSort\">\n    <ng-container *ngFor=\"let column of columns\" matColumnDef={{column.name}}>\n      <th *matHeaderCellDef mat-header-cell> {{column.displayName}} </th>\n      <td *matCellDef=\"let element; index as i\" mat-cell>\n        <span *ngIf=\"!!column.backendPath\"\n              [style]=\"column.style\">{{element[column.backendPath.toString()][column.backendName]}}</span>\n        <span *ngIf=\"column.backendPath === undefined\" [style]=\"column.style\">{{element[column.backendName]}}</span>\n      </td>\n\n      <ng-container *ngIf=\"showStatusLabel\" matColumnDef=\"statusLabelColumn\">\n        <th *matHeaderCellDef mat-header-cell mat-sort-header>{{statusHeaderLabel}}</th>\n        <td *matCellDef=\"let element; index as i\" mat-cell>\n          <engo-uik-status-label [labelData]=\"element.statusLabel\"></engo-uik-status-label>\n        </td>\n      </ng-container>\n    </ng-container>\n  </div>\n\n  <tr *matHeaderRowDef=\"displayedColumns; sticky: true\" mat-header-row></tr>\n  <tr *matRowDef=\"let userdata; columns: displayedColumns;\" mat-row></tr>\n</table>\n<mat-paginator (page)=\"onChangePagination()\"\n               *ngIf=\"enablePagination\"\n               [pageSizeOptions]=\"paginatorPageOptions && paginatorPageOptions.length > 0 ? paginatorPageOptions : [10, 25, 50, 100, 200]\" showFirstLastButtons></mat-paginator>\n", styles: ["table.mat-mdc-table{display:table;width:100%}table{position:sticky}\n"], dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2.MatTable, selector: "mat-table, table[mat-table]", exportAs: ["matTable"] }, { kind: "directive", type: i2.MatHeaderCellDef, selector: "[matHeaderCellDef]" }, { kind: "directive", type: i2.MatHeaderRowDef, selector: "[matHeaderRowDef]", inputs: ["matHeaderRowDef", "matHeaderRowDefSticky"] }, { kind: "directive", type: i2.MatColumnDef, selector: "[matColumnDef]", inputs: ["sticky", "matColumnDef"] }, { kind: "directive", type: i2.MatCellDef, selector: "[matCellDef]" }, { kind: "directive", type: i2.MatRowDef, selector: "[matRowDef]", inputs: ["matRowDefColumns", "matRowDefWhen"] }, { kind: "directive", type: i2.MatHeaderCell, selector: "mat-header-cell, th[mat-header-cell]" }, { kind: "directive", type: i2.MatCell, selector: "mat-cell, td[mat-cell]" }, { kind: "component", type: i2.MatHeaderRow, selector: "mat-header-row, tr[mat-header-row]", exportAs: ["matHeaderRow"] }, { kind: "component", type: i2.MatRow, selector: "mat-row, tr[mat-row]", exportAs: ["matRow"] }, { kind: "directive", type: i3.MatSort, selector: "[matSort]", inputs: ["matSortDisabled", "matSortActive", "matSortStart", "matSortDirection", "matSortDisableClear"], outputs: ["matSortChange"], exportAs: ["matSort"] }, { kind: "component", type: i3.MatSortHeader, selector: "[mat-sort-header]", inputs: ["disabled", "mat-sort-header", "arrowPosition", "start", "sortActionDescription", "disableClear"], exportAs: ["matSortHeader"] }, { kind: "component", type: i4.MatPaginator, selector: "mat-paginator", inputs: ["disabled"], exportAs: ["matPaginator"] }, { kind: "component", type: i5.MatCheckbox, selector: "mat-checkbox", inputs: ["disableRipple", "color", "tabIndex"], exportAs: ["matCheckbox"] }, { kind: "component", type: i6.UikStatusLabelComponent, selector: "engo-uik-status-label", inputs: ["labelData"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: UikTableCheckboxComponent, decorators: [{
            type: Component,
            args: [{ selector: 'engo-uik-table-checkbox', template: "<div *ngIf=\"enableFiltering === true\" class=\"form\">\n  <label class=\"inp\" for=\"inp\">\n    <input (keyup)=\"applyFilter($event)\" id=\"inp-search-filter\" placeholder=\" \" type=\"text\">\n    <span class=\"label\">Suchen & Filtern</span>\n    <span class=\"focus-bg\"></span>\n  </label>\n</div>\n<table #table [dataSource]=\"dataSource\" class=\"inventar-table mat-elevation-z8\" mat-table matSort>\n  <ng-container matColumnDef=\"checkboxColumn\">\n    <th *matHeaderCellDef mat-header-cell></th>\n    <td *matCellDef=\"let element; index as i;\" mat-cell>\n      <mat-checkbox (change)=\"getSelectedRow($event, i)\" *ngIf=\"enableMultipleChecked === true\"\n                    [checked]=\"checkSelectedMultipleInArray(element.id) !== -1\">\n      </mat-checkbox>\n      <mat-checkbox (change)=\"getSelectedRow($event, i)\"\n                    *ngIf=\"enableMultipleChecked === false\"\n                    [checked]=\"checkboxClickedSingleArray?.elementId === element.id\">\n      </mat-checkbox>\n    </td>\n  </ng-container>\n  <div *ngIf=\"enableSort\">\n    <ng-container *ngFor=\"let column of columns\" matColumnDef={{column.name}}>\n      <th *matHeaderCellDef mat-header-cell mat-sort-header> {{column.displayName}} </th>\n      <td *matCellDef=\"let element; index as i\" mat-cell>\n        <span *ngIf=\"!!column.backendPath\"\n              [style]=\"column.style\">{{element[column.backendPath.toString()][column.backendName]}}</span>\n        <span *ngIf=\"column.backendPath === undefined\" [style]=\"column.style\">{{element[column.backendName]}}</span>\n      </td>\n    </ng-container>\n    <ng-container *ngIf=\"showStatusLabel\" matColumnDef=\"statusLabelColumn\">\n      <th *matHeaderCellDef mat-header-cell mat-sort-header>{{statusHeaderLabel}}</th>\n      <td *matCellDef=\"let element; index as i\" mat-cell>\n        <engo-uik-status-label [labelData]=\"element.statusLabel\"></engo-uik-status-label>\n      </td>\n    </ng-container>\n\n  </div>\n\n  <div *ngIf=\"!enableSort\">\n    <ng-container *ngFor=\"let column of columns\" matColumnDef={{column.name}}>\n      <th *matHeaderCellDef mat-header-cell> {{column.displayName}} </th>\n      <td *matCellDef=\"let element; index as i\" mat-cell>\n        <span *ngIf=\"!!column.backendPath\"\n              [style]=\"column.style\">{{element[column.backendPath.toString()][column.backendName]}}</span>\n        <span *ngIf=\"column.backendPath === undefined\" [style]=\"column.style\">{{element[column.backendName]}}</span>\n      </td>\n\n      <ng-container *ngIf=\"showStatusLabel\" matColumnDef=\"statusLabelColumn\">\n        <th *matHeaderCellDef mat-header-cell mat-sort-header>{{statusHeaderLabel}}</th>\n        <td *matCellDef=\"let element; index as i\" mat-cell>\n          <engo-uik-status-label [labelData]=\"element.statusLabel\"></engo-uik-status-label>\n        </td>\n      </ng-container>\n    </ng-container>\n  </div>\n\n  <tr *matHeaderRowDef=\"displayedColumns; sticky: true\" mat-header-row></tr>\n  <tr *matRowDef=\"let userdata; columns: displayedColumns;\" mat-row></tr>\n</table>\n<mat-paginator (page)=\"onChangePagination()\"\n               *ngIf=\"enablePagination\"\n               [pageSizeOptions]=\"paginatorPageOptions && paginatorPageOptions.length > 0 ? paginatorPageOptions : [10, 25, 50, 100, 200]\" showFirstLastButtons></mat-paginator>\n", styles: ["table.mat-mdc-table{display:table;width:100%}table{position:sticky}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { columns: [{
                type: Input
            }], statusHeaderLabel: [{
                type: Input
            }], showStatusLabel: [{
                type: Input
            }], dataSource: [{
                type: Input
            }], enablePagination: [{
                type: Input
            }], paginatorPageOptions: [{
                type: Input
            }], enableSort: [{
                type: Input
            }], enableFiltering: [{
                type: Input
            }], enableMultipleChecked: [{
                type: Input
            }], checkboxClickedMultipleEmitter: [{
                type: Output
            }], checkboxClickedSingleEmitter: [{
                type: Output
            }], paginator: [{
                type: ViewChild,
                args: [MatPaginator]
            }], sort: [{
                type: ViewChild,
                args: [MatSort]
            }], table: [{
                type: ViewChild,
                args: [MatTable]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidWlrLXRhYmxlLWNoZWNrYm94LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2VuZ28tdWkta2l0LWxpYi9zcmMvbGliL3Vpay10YWJsZS1jaGVja2JveC91aWstdGFibGUtY2hlY2tib3guY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvZW5nby11aS1raXQtbGliL3NyYy9saWIvdWlrLXRhYmxlLWNoZWNrYm94L3Vpay10YWJsZS1jaGVja2JveC5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ1UsU0FBUyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQXFCLE1BQU0sRUFBaUIsU0FBUyxFQUNuRyxNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDM0QsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ2pELE9BQU8sRUFBRSxRQUFRLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQzs7Ozs7Ozs7QUFTdkUsTUFBTSxPQUFPLHlCQUF5QjtJQThCcEM7UUE3QlMsWUFBTyxHQUEyQixTQUFTLENBQUM7UUFFNUMsb0JBQWUsR0FBRyxJQUFJLENBQUM7UUFDdkIsZUFBVSxHQUE0QixJQUFJLGtCQUFrQixFQUFFLENBQUM7UUFDL0QscUJBQWdCLEdBQUcsS0FBSyxDQUFDO1FBRXpCLGVBQVUsR0FBRyxLQUFLLENBQUM7UUFDbkIsb0JBQWUsR0FBRyxLQUFLLENBQUM7UUFDeEIsMEJBQXFCLEdBQUcsSUFBSSxDQUFDO1FBRTVCLG1DQUE4QixHQUEwQyxJQUFJLFlBQVksRUFBMkIsQ0FBQztRQUNwSCxpQ0FBNEIsR0FBd0MsSUFBSSxZQUFZLEVBQXlCLENBQUM7UUFVeEgscUJBQWdCLEdBQWEsRUFBRSxDQUFDO1FBQ2hDLGlDQUE0QixHQUE0QixF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QUMsVUFBVSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO1NBQzVDO0lBQ0gsQ0FBQzsrR0E1SlUseUJBQXlCO21HQUF6Qix5QkFBeUIsK2pCQWN6QixZQUFZLHVFQUdaLE9BQU8sd0VBRVAsUUFBUSxxRUNsQ3JCLDR5R0E4REE7OzRGRC9DYSx5QkFBeUI7a0JBTHJDLFNBQVM7K0JBQ0UseUJBQXlCOzBFQUsxQixPQUFPO3NCQUFmLEtBQUs7Z0JBQ0csaUJBQWlCO3NCQUF6QixLQUFLO2dCQUNHLGVBQWU7c0JBQXZCLEtBQUs7Z0JBQ0csVUFBVTtzQkFBbEIsS0FBSztnQkFDRyxnQkFBZ0I7c0JBQXhCLEtBQUs7Z0JBQ0csb0JBQW9CO3NCQUE1QixLQUFLO2dCQUNHLFVBQVU7c0JBQWxCLEtBQUs7Z0JBQ0csZUFBZTtzQkFBdkIsS0FBSztnQkFDRyxxQkFBcUI7c0JBQTdCLEtBQUs7Z0JBRUksOEJBQThCO3NCQUF2QyxNQUFNO2dCQUNHLDRCQUE0QjtzQkFBckMsTUFBTTtnQkFHUCxTQUFTO3NCQURSLFNBQVM7dUJBQUMsWUFBWTtnQkFHSCxJQUFJO3NCQUF2QixTQUFTO3VCQUFDLE9BQU87Z0JBR2xCLEtBQUs7c0JBREosU0FBUzt1QkFBQyxRQUFRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkNoYW5nZXMsIE9uSW5pdCwgT3V0cHV0LCBTaW1wbGVDaGFuZ2VzLCBWaWV3Q2hpbGRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNYXRDaGVja2JveENoYW5nZSB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2NoZWNrYm94JztcbmltcG9ydCB7IE1hdFBhZ2luYXRvciB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL3BhZ2luYXRvcic7XG5pbXBvcnQgeyBNYXRTb3J0IH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvc29ydCc7XG5pbXBvcnQgeyBNYXRUYWJsZSwgTWF0VGFibGVEYXRhU291cmNlIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvdGFibGUnO1xuaW1wb3J0IHsgSUNvbHVtbnMgfSBmcm9tICcuLi91aWstdGFibGUvaW50ZXJmYWNlcy91aWstdGFibGUuaW50ZXJmYWNlJztcbmltcG9ydCB7IElDaGVja2JveFRhYmxlQ2xpY2tlZCB9IGZyb20gJy4vaW50ZXJmYWNlcy91aWstdGFibGUtY2hlY2tib3guaW50ZXJmYWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZW5nby11aWstdGFibGUtY2hlY2tib3gnLFxuICB0ZW1wbGF0ZVVybDogJy4vdWlrLXRhYmxlLWNoZWNrYm94LmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vdWlrLXRhYmxlLWNoZWNrYm94LmNvbXBvbmVudC5jc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBVaWtUYWJsZUNoZWNrYm94Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0LCBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBjb2x1bW5zOiBJQ29sdW1uc1tdIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBASW5wdXQoKSBzdGF0dXNIZWFkZXJMYWJlbD86IHN0cmluZztcbiAgQElucHV0KCkgc2hvd1N0YXR1c0xhYmVsID0gdHJ1ZTtcbiAgQElucHV0KCkgZGF0YVNvdXJjZTogTWF0VGFibGVEYXRhU291cmNlPGFueT4gPSBuZXcgTWF0VGFibGVEYXRhU291cmNlKCk7XG4gIEBJbnB1dCgpIGVuYWJsZVBhZ2luYXRpb24gPSBmYWxzZTtcbiAgQElucHV0KCkgcGFnaW5hdG9yUGFnZU9wdGlvbnM/OiBBcnJheTxudW1iZXI+O1xuICBASW5wdXQoKSBlbmFibGVTb3J0ID0gZmFsc2U7XG4gIEBJbnB1dCgpIGVuYWJsZUZpbHRlcmluZyA9IGZhbHNlO1xuICBASW5wdXQoKSBlbmFibGVNdWx0aXBsZUNoZWNrZWQgPSB0cnVlO1xuXG4gIEBPdXRwdXQoKSBjaGVja2JveENsaWNrZWRNdWx0aXBsZUVtaXR0ZXI6IEV2ZW50RW1pdHRlcjxJQ2hlY2tib3hUYWJsZUNsaWNrZWRbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPElDaGVja2JveFRhYmxlQ2xpY2tlZFtdPigpO1xuICBAT3V0cHV0KCkgY2hlY2tib3hDbGlja2VkU2luZ2xlRW1pdHRlcjogRXZlbnRFbWl0dGVyPElDaGVja2JveFRhYmxlQ2xpY2tlZD4gPSBuZXcgRXZlbnRFbWl0dGVyPElDaGVja2JveFRhYmxlQ2xpY2tlZD4oKTtcblxuICBAVmlld0NoaWxkKE1hdFBhZ2luYXRvcilcbiAgcGFnaW5hdG9yITogTWF0UGFnaW5hdG9yIHwgbnVsbDtcblxuICBAVmlld0NoaWxkKE1hdFNvcnQpIHNvcnQhOiBNYXRTb3J0O1xuXG4gIEBWaWV3Q2hpbGQoTWF0VGFibGUpXG4gIHRhYmxlITogTWF0VGFibGU8YW55PjtcblxuICBkaXNwbGF5ZWRDb2x1bW5zOiBzdHJpbmdbXSA9IFtdO1xuICBjaGVja2JveENsaWNrZWRNdWx0aXBsZUFycmF5OiBJQ2hlY2tib3hUYWJsZUNsaWNrZWRbXSA9IFtdO1xuICBjaGVja2JveENsaWNrZWRTaW5nbGVBcnJheTogSUNoZWNrYm94VGFibGVDbGlja2VkIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBwdWJsaWMgcGFnZUluZGV4ID0gMDtcbiAgcHVibGljIHBhZ2VTaXplID0gMDtcbiAgcHVibGljIGNvcnJlY3RJbmRleCA9IDA7XG5cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyRGlzcGxheWVkQ29sdW1ucygpO1xuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyU29ydGluZygpO1xuICAgIHRoaXMucmVuZGVyUGFnaW5hdGlvbigpO1xuICAgIHRoaXMucmVuZGVyU3RhdHVzTGFiZWwoKTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAodGhpcy50YWJsZSkge1xuICAgICAgaWYgKGNoYW5nZXNbXCJkYXRhU291cmNlXCJdKSB7XG4gICAgICAgIHRoaXMudGFibGUuZGF0YVNvdXJjZSA9IHRoaXMuZGF0YVNvdXJjZTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGFibGUucmVuZGVyUm93cygpO1xuICAgICAgdGhpcy5yZW5kZXJTb3J0aW5nKCk7XG4gICAgICB0aGlzLnJlbmRlclBhZ2luYXRpb24oKTtcbiAgICAgIHRoaXMucmVuZGVyU3RhdHVzTGFiZWwoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXBwbHlGaWx0ZXIoZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgY29uc3QgZmlsdGVyVmFsdWUgPSAoZXZlbnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlO1xuICAgIHRoaXMuZGF0YVNvdXJjZS5maWx0ZXIgPSBmaWx0ZXJWYWx1ZS50cmltKCkudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmICh0aGlzLmRhdGFTb3VyY2UucGFnaW5hdG9yKSB7XG4gICAgICB0aGlzLmRhdGFTb3VyY2UucGFnaW5hdG9yLmZpcnN0UGFnZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lbmFibGVNdWx0aXBsZUNoZWNrZWQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmNoZWNrYm94Q2xpY2tlZFNpbmdsZUFycmF5ID0ge2VsZW1lbnRJZDogLTF9O1xuICAgICAgdGhpcy5lbWl0Q2hlY2tib3hDbGlja2VkU2luZ2xlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVuYWJsZU11bHRpcGxlQ2hlY2tlZCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5jaGVja2JveENsaWNrZWRNdWx0aXBsZUFycmF5ID0gW107XG4gICAgICB0aGlzLmVtaXRDaGVja2JveENsaWNrZWRNdWx0aXBsZSgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRTZWxlY3RlZFJvdyhldmVudDogTWF0Q2hlY2tib3hDaGFuZ2UsIGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5wYWdpbmF0b3IgJiYgdGhpcy5lbmFibGVQYWdpbmF0aW9uID09PSB0cnVlKSB7XG4gICAgICB0aGlzLnBhZ2VJbmRleCA9IHRoaXMucGFnaW5hdG9yLnBhZ2VJbmRleDtcbiAgICAgIHRoaXMucGFnZVNpemUgPSB0aGlzLnBhZ2luYXRvci5wYWdlU2l6ZTtcbiAgICAgIHRoaXMuY29ycmVjdEluZGV4ID0gdGhpcy5wYWdlSW5kZXggKiB0aGlzLnBhZ2VTaXplO1xuICAgICAgaW5kZXggPSBpbmRleCArIHRoaXMuY29ycmVjdEluZGV4O1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW1lbnRJZCA9IHRoaXMuZGF0YVNvdXJjZS5maWx0ZXJlZERhdGFbaW5kZXhdLmlkO1xuXG4gICAgaWYgKGV2ZW50LmNoZWNrZWQgPT09IHRydWUpIHtcbiAgICAgIGlmICh0aGlzLmVuYWJsZU11bHRpcGxlQ2hlY2tlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5jaGVja2JveENsaWNrZWRTaW5nbGVBcnJheSA9IHtlbGVtZW50SWR9O1xuICAgICAgICB0aGlzLmVtaXRDaGVja2JveENsaWNrZWRTaW5nbGUoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuYWJsZU11bHRpcGxlQ2hlY2tlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmNoZWNrYm94Q2xpY2tlZE11bHRpcGxlQXJyYXkucHVzaCh7ZWxlbWVudElkfSk7XG4gICAgICAgIHRoaXMuZW1pdENoZWNrYm94Q2xpY2tlZE11bHRpcGxlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChldmVudC5jaGVja2VkID09PSBmYWxzZSkge1xuICAgICAgaWYgKHRoaXMuZW5hYmxlTXVsdGlwbGVDaGVja2VkID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmNoZWNrYm94Q2xpY2tlZFNpbmdsZUFycmF5ID0ge2VsZW1lbnRJZDogLTF9O1xuICAgICAgICB0aGlzLmVtaXRDaGVja2JveENsaWNrZWRTaW5nbGUoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuYWJsZU11bHRpcGxlQ2hlY2tlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBhcnJheUluZGV4ID0gdGhpcy5jaGVja2JveENsaWNrZWRNdWx0aXBsZUFycmF5LmZpbmRJbmRleChlID0+IGUuZWxlbWVudElkID09PSBlbGVtZW50SWQpO1xuICAgICAgICB0aGlzLmNoZWNrYm94Q2xpY2tlZE11bHRpcGxlQXJyYXkuc3BsaWNlKGFycmF5SW5kZXgsIDEpO1xuICAgICAgICB0aGlzLmVtaXRDaGVja2JveENsaWNrZWRNdWx0aXBsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBvbkNoYW5nZVBhZ2luYXRpb24oKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZW5hYmxlTXVsdGlwbGVDaGVja2VkID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5jaGVja2JveENsaWNrZWRTaW5nbGVBcnJheSA9IHtlbGVtZW50SWQ6IC0xfTtcbiAgICAgIHRoaXMuZW1pdENoZWNrYm94Q2xpY2tlZFNpbmdsZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lbmFibGVNdWx0aXBsZUNoZWNrZWQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuY2hlY2tib3hDbGlja2VkTXVsdGlwbGVBcnJheSA9IFtdO1xuICAgICAgdGhpcy5lbWl0Q2hlY2tib3hDbGlja2VkTXVsdGlwbGUoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY2hlY2tTZWxlY3RlZE11bHRpcGxlSW5BcnJheShpZDogbnVtYmVyIHwgc3RyaW5nKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5jaGVja2JveENsaWNrZWRNdWx0aXBsZUFycmF5LmZpbmRJbmRleChlbGVtZW50ID0+IGVsZW1lbnQuZWxlbWVudElkID09PSBpZCk7XG4gIH1cblxuICBwdWJsaWMgZW1pdENoZWNrYm94Q2xpY2tlZE11bHRpcGxlKCk6IHZvaWQge1xuICAgIHRoaXMuY2hlY2tib3hDbGlja2VkTXVsdGlwbGVFbWl0dGVyLmVtaXQodGhpcy5jaGVja2JveENsaWNrZWRNdWx0aXBsZUFycmF5KTtcbiAgfVxuXG4gIHB1YmxpYyBlbWl0Q2hlY2tib3hDbGlja2VkU2luZ2xlKCk6IHZvaWQge1xuICAgIHRoaXMuY2hlY2tib3hDbGlja2VkU2luZ2xlRW1pdHRlci5lbWl0KHRoaXMuY2hlY2tib3hDbGlja2VkU2luZ2xlQXJyYXkpO1xuICB9XG5cbiAgcHJpdmF0ZSByZW5kZXJEaXNwbGF5ZWRDb2x1bW5zKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNvbHVtbnMpIHtcbiAgICAgIHRoaXMuZGlzcGxheWVkQ29sdW1ucy5wdXNoKCdjaGVja2JveENvbHVtbicpO1xuICAgICAgZm9yIChjb25zdCBjb2x1bW4gb2YgdGhpcy5jb2x1bW5zKSB7XG4gICAgICAgIHRoaXMuZGlzcGxheWVkQ29sdW1ucy5wdXNoKGNvbHVtbi5uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlbmRlclN0YXR1c0xhYmVsKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnNob3dTdGF0dXNMYWJlbCkge1xuICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZENvbHVtbnMuaW5jbHVkZXMoJ3N0YXR1c0xhYmVsQ29sdW1uJykpIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRDb2x1bW5zLnB1c2goJ3N0YXR1c0xhYmVsQ29sdW1uJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmRhdGFTb3VyY2UuZGF0YS5mb3JFYWNoKGVsZW1lbnQgPT4gZWxlbWVudC5zdGF0dXNMYWJlbENvbHVtbiA9IGVsZW1lbnQuc3RhdHVzTGFiZWwubGFiZWxWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZW5kZXJTb3J0aW5nKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmVuYWJsZVNvcnQpIHtcbiAgICAgIHRoaXMuZGF0YVNvdXJjZS5zb3J0ID0gdGhpcy5zb3J0O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVuZGVyUGFnaW5hdGlvbigpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5lbmFibGVQYWdpbmF0aW9uKSB7XG4gICAgICB0aGlzLmRhdGFTb3VyY2UucGFnaW5hdG9yID0gdGhpcy5wYWdpbmF0b3I7XG4gICAgfVxuICB9XG59XG4iLCI8ZGl2ICpuZ0lmPVwiZW5hYmxlRmlsdGVyaW5nID09PSB0cnVlXCIgY2xhc3M9XCJmb3JtXCI+XG4gIDxsYWJlbCBjbGFzcz1cImlucFwiIGZvcj1cImlucFwiPlxuICAgIDxpbnB1dCAoa2V5dXApPVwiYXBwbHlGaWx0ZXIoJGV2ZW50KVwiIGlkPVwiaW5wLXNlYXJjaC1maWx0ZXJcIiBwbGFjZWhvbGRlcj1cIiBcIiB0eXBlPVwidGV4dFwiPlxuICAgIDxzcGFuIGNsYXNzPVwibGFiZWxcIj5TdWNoZW4gJiBGaWx0ZXJuPC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwiZm9jdXMtYmdcIj48L3NwYW4+XG4gIDwvbGFiZWw+XG48L2Rpdj5cbjx0YWJsZSAjdGFibGUgW2RhdGFTb3VyY2VdPVwiZGF0YVNvdXJjZVwiIGNsYXNzPVwiaW52ZW50YXItdGFibGUgbWF0LWVsZXZhdGlvbi16OFwiIG1hdC10YWJsZSBtYXRTb3J0PlxuICA8bmctY29udGFpbmVyIG1hdENvbHVtbkRlZj1cImNoZWNrYm94Q29sdW1uXCI+XG4gICAgPHRoICptYXRIZWFkZXJDZWxsRGVmIG1hdC1oZWFkZXItY2VsbD48L3RoPlxuICAgIDx0ZCAqbWF0Q2VsbERlZj1cImxldCBlbGVtZW50OyBpbmRleCBhcyBpO1wiIG1hdC1jZWxsPlxuICAgICAgPG1hdC1jaGVja2JveCAoY2hhbmdlKT1cImdldFNlbGVjdGVkUm93KCRldmVudCwgaSlcIiAqbmdJZj1cImVuYWJsZU11bHRpcGxlQ2hlY2tlZCA9PT0gdHJ1ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtjaGVja2VkXT1cImNoZWNrU2VsZWN0ZWRNdWx0aXBsZUluQXJyYXkoZWxlbWVudC5pZCkgIT09IC0xXCI+XG4gICAgICA8L21hdC1jaGVja2JveD5cbiAgICAgIDxtYXQtY2hlY2tib3ggKGNoYW5nZSk9XCJnZXRTZWxlY3RlZFJvdygkZXZlbnQsIGkpXCJcbiAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJlbmFibGVNdWx0aXBsZUNoZWNrZWQgPT09IGZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgW2NoZWNrZWRdPVwiY2hlY2tib3hDbGlja2VkU2luZ2xlQXJyYXk/LmVsZW1lbnRJZCA9PT0gZWxlbWVudC5pZFwiPlxuICAgICAgPC9tYXQtY2hlY2tib3g+XG4gICAgPC90ZD5cbiAgPC9uZy1jb250YWluZXI+XG4gIDxkaXYgKm5nSWY9XCJlbmFibGVTb3J0XCI+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGNvbHVtbnNcIiBtYXRDb2x1bW5EZWY9e3tjb2x1bW4ubmFtZX19PlxuICAgICAgPHRoICptYXRIZWFkZXJDZWxsRGVmIG1hdC1oZWFkZXItY2VsbCBtYXQtc29ydC1oZWFkZXI+IHt7Y29sdW1uLmRpc3BsYXlOYW1lfX0gPC90aD5cbiAgICAgIDx0ZCAqbWF0Q2VsbERlZj1cImxldCBlbGVtZW50OyBpbmRleCBhcyBpXCIgbWF0LWNlbGw+XG4gICAgICAgIDxzcGFuICpuZ0lmPVwiISFjb2x1bW4uYmFja2VuZFBhdGhcIlxuICAgICAgICAgICAgICBbc3R5bGVdPVwiY29sdW1uLnN0eWxlXCI+e3tlbGVtZW50W2NvbHVtbi5iYWNrZW5kUGF0aC50b1N0cmluZygpXVtjb2x1bW4uYmFja2VuZE5hbWVdfX08L3NwYW4+XG4gICAgICAgIDxzcGFuICpuZ0lmPVwiY29sdW1uLmJhY2tlbmRQYXRoID09PSB1bmRlZmluZWRcIiBbc3R5bGVdPVwiY29sdW1uLnN0eWxlXCI+e3tlbGVtZW50W2NvbHVtbi5iYWNrZW5kTmFtZV19fTwvc3Bhbj5cbiAgICAgIDwvdGQ+XG4gICAgPC9uZy1jb250YWluZXI+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInNob3dTdGF0dXNMYWJlbFwiIG1hdENvbHVtbkRlZj1cInN0YXR1c0xhYmVsQ29sdW1uXCI+XG4gICAgICA8dGggKm1hdEhlYWRlckNlbGxEZWYgbWF0LWhlYWRlci1jZWxsIG1hdC1zb3J0LWhlYWRlcj57e3N0YXR1c0hlYWRlckxhYmVsfX08L3RoPlxuICAgICAgPHRkICptYXRDZWxsRGVmPVwibGV0IGVsZW1lbnQ7IGluZGV4IGFzIGlcIiBtYXQtY2VsbD5cbiAgICAgICAgPGVuZ28tdWlrLXN0YXR1cy1sYWJlbCBbbGFiZWxEYXRhXT1cImVsZW1lbnQuc3RhdHVzTGFiZWxcIj48L2VuZ28tdWlrLXN0YXR1cy1sYWJlbD5cbiAgICAgIDwvdGQ+XG4gICAgPC9uZy1jb250YWluZXI+XG5cbiAgPC9kaXY+XG5cbiAgPGRpdiAqbmdJZj1cIiFlbmFibGVTb3J0XCI+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGNvbHVtbnNcIiBtYXRDb2x1bW5EZWY9e3tjb2x1bW4ubmFtZX19PlxuICAgICAgPHRoICptYXRIZWFkZXJDZWxsRGVmIG1hdC1oZWFkZXItY2VsbD4ge3tjb2x1bW4uZGlzcGxheU5hbWV9fSA8L3RoPlxuICAgICAgPHRkICptYXRDZWxsRGVmPVwibGV0IGVsZW1lbnQ7IGluZGV4IGFzIGlcIiBtYXQtY2VsbD5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCIhIWNvbHVtbi5iYWNrZW5kUGF0aFwiXG4gICAgICAgICAgICAgIFtzdHlsZV09XCJjb2x1bW4uc3R5bGVcIj57e2VsZW1lbnRbY29sdW1uLmJhY2tlbmRQYXRoLnRvU3RyaW5nKCldW2NvbHVtbi5iYWNrZW5kTmFtZV19fTwvc3Bhbj5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJjb2x1bW4uYmFja2VuZFBhdGggPT09IHVuZGVmaW5lZFwiIFtzdHlsZV09XCJjb2x1bW4uc3R5bGVcIj57e2VsZW1lbnRbY29sdW1uLmJhY2tlbmROYW1lXX19PC9zcGFuPlxuICAgICAgPC90ZD5cblxuICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInNob3dTdGF0dXNMYWJlbFwiIG1hdENvbHVtbkRlZj1cInN0YXR1c0xhYmVsQ29sdW1uXCI+XG4gICAgICAgIDx0aCAqbWF0SGVhZGVyQ2VsbERlZiBtYXQtaGVhZGVyLWNlbGwgbWF0LXNvcnQtaGVhZGVyPnt7c3RhdHVzSGVhZGVyTGFiZWx9fTwvdGg+XG4gICAgICAgIDx0ZCAqbWF0Q2VsbERlZj1cImxldCBlbGVtZW50OyBpbmRleCBhcyBpXCIgbWF0LWNlbGw+XG4gICAgICAgICAgPGVuZ28tdWlrLXN0YXR1cy1sYWJlbCBbbGFiZWxEYXRhXT1cImVsZW1lbnQuc3RhdHVzTGFiZWxcIj48L2VuZ28tdWlrLXN0YXR1cy1sYWJlbD5cbiAgICAgICAgPC90ZD5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvbmctY29udGFpbmVyPlxuICA8L2Rpdj5cblxuICA8dHIgKm1hdEhlYWRlclJvd0RlZj1cImRpc3BsYXllZENvbHVtbnM7IHN0aWNreTogdHJ1ZVwiIG1hdC1oZWFkZXItcm93PjwvdHI+XG4gIDx0ciAqbWF0Um93RGVmPVwibGV0IHVzZXJkYXRhOyBjb2x1bW5zOiBkaXNwbGF5ZWRDb2x1bW5zO1wiIG1hdC1yb3c+PC90cj5cbjwvdGFibGU+XG48bWF0LXBhZ2luYXRvciAocGFnZSk9XCJvbkNoYW5nZVBhZ2luYXRpb24oKVwiXG4gICAgICAgICAgICAgICAqbmdJZj1cImVuYWJsZVBhZ2luYXRpb25cIlxuICAgICAgICAgICAgICAgW3BhZ2VTaXplT3B0aW9uc109XCJwYWdpbmF0b3JQYWdlT3B0aW9ucyAmJiBwYWdpbmF0b3JQYWdlT3B0aW9ucy5sZW5ndGggPiAwID8gcGFnaW5hdG9yUGFnZU9wdGlvbnMgOiBbMTAsIDI1LCA1MCwgMTAwLCAyMDBdXCIgc2hvd0ZpcnN0TGFzdEJ1dHRvbnM+PC9tYXQtcGFnaW5hdG9yPlxuIl19